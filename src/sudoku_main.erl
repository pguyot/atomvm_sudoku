% Copyright 2023 Paul Guyot <pguyot@kallisys.net>
% SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later

-module(sudoku_main).

-export([start_link/0]).

-behavior(gen_server).
-export([init/1, handle_cast/2, handle_call/3, handle_info/2, terminate/2]).

-include("dom.hrl").

start_link() ->
    gen_server:start_link(?MODULE, [], []).

-record(state, {countdown :: integer(), start :: integer()}).

-define(COUNT_DOWN, 10).
-define(MAX_PROCESSING_TIME, ?COUNT_DOWN * 1000 - 500).

init([]) ->
    LoaderScript = loader_init_script(?COUNT_DOWN),
    emscripten:run_script(LoaderScript, [main_thread, async]),
    Self = self(),
    Start = erlang:system_time(millisecond),
    spawn_link(fun() -> generate_grid(Self) end),
    {ok, #state{countdown = ?COUNT_DOWN, start = Start}, 1000}.

handle_cast(_Msg, #state{} = State0) ->
    {noreply, State0}.

handle_call(_Request, _From, State) ->
    {reply, {error, unimplemented}, State}.

handle_info(timeout, State) ->
    UpdateScript = loader_update_script(State#state.countdown),
    emscripten:run_script(UpdateScript, [main_thread, async]),
    case State#state.countdown of
        0 -> {noreply, State};
        N -> {noreply, State#state{countdown = N - 1}, 1000}
    end;
handle_info({puzzle, Puzzle}, State) ->
    End = erlang:system_time(millisecond),
    Delta = End - State#state.start,
    PuzzleScript = create_puzzle_script(Puzzle, Delta),
    emscripten:run_script(PuzzleScript, [main_thread, async]),
    {noreply, State}.

terminate(_Reason, #state{}) ->
    ok.

loader_init_script(CountDown) ->
    {Script, _} = dom:append_child_script(<<"#root">>, loader_element(CountDown), 1),
    Script.

loader_update_script(N) when N > 0 ->
    {Script, _} = dom:replace_children_script(<<".loader-countdown">>, integer_to_binary(N), 1),
    Script;
loader_update_script(0) ->
    {Script, _} = dom:replace_children_script(<<"#loader">>, late_loader_element(), 1),
    Script.

create_puzzle_script(Puzzle, Delta) ->
    {Script, _} = dom:replace_with_script(<<"#loader">>, puzzle_element(Puzzle, Delta), 1),
    Script.

loader_element(N) ->
    #element{
        name = 'div',
        attributes = [{id, <<"loader">>}],
        children = [
            #element{
                name = 'div',
                attributes = [{class, <<"loader-countdown">>}],
                children = [integer_to_binary(N)]
            },
            #element{
                name = p,
                attributes = [{class, <<"loader-caption">>}],
                children = [<<"Creating a completely random new grid">>]
            }
        ]
    }.

late_loader_element() ->
    #element{
        name = 'div',
        attributes = [{class, <<"late-loader-caption">>}],
        children = [<<"Still creating a grid...">>]
    }.

puzzle_element(Puzzle, Delta) ->
    #element{
        name = 'table',
        attributes = [{class, <<"sudoku-grid">>}],
        children =
            [puzzle_caption(Delta)] ++
                [puzzle_row(X, Puzzle) || X <- lists:seq(1, 9)]
    }.

puzzle_caption(Delta) ->
    #element{
        name = 'caption',
        children = [list_to_binary(io_lib:format("Grid generated by AtomVM in ~Bms", [Delta]))]
    }.

puzzle_row(X, Puzzle) ->
    #element{name = 'tr', children = [puzzle_cell(X, Y, Puzzle) || Y <- lists:seq(1, 9)]}.

puzzle_cell(X, Y, Puzzle) ->
    Children =
        case maps:get({X, Y}, Puzzle) of
            0 -> [];
            Hint -> [integer_to_binary(Hint)]
        end,
    #element{name = 'td', children = Children}.

generate_grid(Parent) ->
    RandomGenerator = fun(X) -> (atomvm:random() rem X) + 1 end,
    Puzzle = sudoku_grid:parallel_random_puzzle(RandomGenerator, 25, 4, ?MAX_PROCESSING_TIME),
    Parent ! {puzzle, Puzzle}.
